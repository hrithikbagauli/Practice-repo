we install @types/node because some methods are only available inside node js and not javascript so if we tried to run our node js code in the browser, it won't work. for example, the require method only works in node js so typescript shows an error because it doesn't know that this method exists. So, to let typescript know that it exists, we install a dependency called '@types/node' for the development phase using the command:- npm install --save-dev @types/node  .
this package basically lets us run node js code in typescript by translating our node js code to javascript. 
----------------------------------------------------
we need to install @types/express because typescript doesn't know what express code looks like or how its methods are implemented. This is why we need to install types/express so that we're able to use express methods and also take advantage of the typescript features that help avoid errors.
----------------------------------------------------
moduleResolution basically tells the compiler, where to find a particular import. If its value is set to node, it'll look for the imports in the node_modules folder. This is why we need to change moduleResolution so that the typescript compiler knows where to find the imported modules.
-----------------------------------------------------
import is similar to require because typescript converts the import keyword to require in the js file.
-----------------------------------------------------
there are two syntaxes of importing:-
   a) import express = require('express');
   b) import express from 'express';
-----------------------------------------------------
import {Router} from 'express' works by importing only the Router object from the express package inside the node_modules folder. It allows us to import only the package we need. Without it, we would first need to import the express package and then extract the Router object from that.
-----------------------------------------------------
interface is a way of defining the structure of an object. It can also be used to define methods and properties that a class must implement. We have to create it for todos type to define a specific structure for the todos to make sure that the values that do not follow the structure are not allowed.
-----------------------------------------------------
named exports are used to export multiple values from a module, while default exports are used to export a single value as the default export from a module. We use the 'export' keyword for a named export and the 'export default' for a default export.
-----------------------------------------------------
we use RequestBody and RequestParams because typescript can only predict the values that'll go inside the req object but it doesn't know what will be inside the body of the request i.e. req.body and that's why keeps the type set as 'any' for req.body, but since the entire point of typescript is to write error-proof code, we need to use typecasting to avoid errors.
------------------------------------------------------
Our file structure becomes messy when we have multiple js files after converting the ts file to js. To fix this, we set the value of outDir to the folder where we want to store the .js files i.e. ./dist in this case, and rootDir to the folder that contains all the .ts files i.e. ./src in this case.
--------------------------------------------------------
we add node dist/app.js in package.json to provide the script so that we can use the 'npm start' command and directly start the server instead of writing node dist/app.js everytime we make a change in our code. In addition to that, we can also use the nodemon package to automatically restart the server when we make a change in our code.